<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/maxogden/websocket-stream#readme">websocket-stream (v4.0.0)</a>
</h1>
<h4>Use websockets with the node streams API. Works in browser and node</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.websocket-stream">module websocket-stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.websocket-stream">
            function <span class="apidocSignatureSpan"></span>websocket-stream
            <span class="apidocSignatureSpan">(target, protocols, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.Server">
            function <span class="apidocSignatureSpan">websocket-stream.</span>Server
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.createServer">
            function <span class="apidocSignatureSpan">websocket-stream.</span>createServer
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.stream">
            function <span class="apidocSignatureSpan">websocket-stream.</span>stream
            <span class="apidocSignatureSpan">(target, protocols, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">websocket-stream.</span>echo_server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">websocket-stream.</span>server</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.websocket-stream.echo_server">module websocket-stream.echo_server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.echo_server.start">
            function <span class="apidocSignatureSpan">websocket-stream.echo_server.</span>start
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.echo_server.stop">
            function <span class="apidocSignatureSpan">websocket-stream.echo_server.</span>stop
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">websocket-stream.echo_server.</span>port</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">websocket-stream.echo_server.</span>url</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.websocket-stream.server">module websocket-stream.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.server.Server">
            function <span class="apidocSignatureSpan">websocket-stream.server.</span>Server
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.server.createServer">
            function <span class="apidocSignatureSpan">websocket-stream.server.</span>createServer
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.websocket-stream.stream">module websocket-stream.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.stream.stream">
            function <span class="apidocSignatureSpan">websocket-stream.</span>stream
            <span class="apidocSignatureSpan">(target, protocols, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.stream.Server">
            function <span class="apidocSignatureSpan">websocket-stream.stream.</span>Server
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.websocket-stream.stream.createServer">
            function <span class="apidocSignatureSpan">websocket-stream.stream.</span>createServer
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.websocket-stream" id="apidoc.module.websocket-stream">module websocket-stream</a></h1>


    <h2>
        <a href="#apidoc.element.websocket-stream.websocket-stream" id="apidoc.element.websocket-stream.websocket-stream">
        function <span class="apidocSignatureSpan"></span>websocket-stream
        <span class="apidocSignatureSpan">(target, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketStream(target, protocols, options) {
  var stream, socket

  var isBrowser = process.title === 'browser'
  var isNative = !!global.WebSocket
  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode

  if (protocols &amp;&amp; !Array.isArray(protocols) &amp;&amp; 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols
    protocols = null

    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {
      protocols = options.protocol;
    }
  }

  if (!options) options = {}

  if (options.objectMode === undefined) {
    options.objectMode = !(options.binary === true || options.binary === undefined)
  }

  var proxy = buildProxy(options, socketWrite, socketEnd)

  if (!options.objectMode) {
    proxy._writev = writev
  }

  // browser only: sets the maximum socket buffer size before throttling
  var bufferSize = options.browserBufferSize || 1024 * 512

  // browser only: how long to wait when throttling
  var bufferTimeout = options.browserBufferTimeout || 1000

  // use existing WebSocket object that was passed in
  if (typeof target === 'object') {
    socket = target
  // otherwise make a new one
  } else {
    // special constructor treatment for native websockets in browsers, see
    // https://github.com/maxogden/websocket-stream/issues/82
    if (isNative &amp;&amp; isBrowser) {
      socket = new WS(target, protocols)
    } else {
      socket = new WS(target, protocols, options)
    }

    socket.binaryType = 'arraybuffer'
  }

  // was already open when passed in
  if (socket.readyState === WS.OPEN) {
    stream = proxy
  } else {
    stream = duplexify.obj()
    socket.onopen = onopen
  }

  stream.socket = socket

  socket.onclose = onclose
  socket.onerror = onerror
  socket.onmessage = onmessage

  proxy.on('close', destroy)

  var coerceToBuffer = !options.objectMode

  function socketWriteNode(chunk, enc, next) {
    // avoid errors, this never happens unless
    // destroy() is called
    if (socket.readyState !== WS.OPEN) {
      next()
      return
    }

    if (coerceToBuffer &amp;&amp; typeof chunk === 'string') {
      chunk = new Buffer(chunk, 'utf8')
    }
    socket.send(chunk, next)
  }

  function socketWriteBrowser(chunk, enc, next) {
    if (socket.bufferedAmount &gt; bufferSize) {
      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)
      return
    }

    if (coerceToBuffer &amp;&amp; typeof chunk === 'string') {
      chunk = new Buffer(chunk, 'utf8')
    }

    try {
      socket.send(chunk)
    } catch(err) {
      return next(err)
    }

    next()
  }

  function socketEnd(done) {
    socket.close()
    done()
  }

  function onopen() {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  }

  function onclose() {
    stream.end()
    stream.destroy()
  }

  function onerror(err) {
    stream.destroy(err)
  }

  function onmessage(event) {
    var data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(new Uint8Array(data))
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  }

  function destroy() {
    socket.close()
  }

  // this is to be enabled only if objectMode is false
  function writev (chunks, cb) {
    var buffers = new Array(chunks.length)
    for (var i = 0; i &lt; chunks.length; i++) {
      if (typeof chunks[i].chunk === 'string') {
        buffers[i] = Buffer.from(chunks[i], 'utf8')
      } else {
        buffers[i] = chunks[i].chunk
      }
    }

    this._write(Buffer.concat(buffers), 'binary', cb)
  }

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.websocket-stream.Server" id="apidoc.element.websocket-stream.Server">
        function <span class="apidocSignatureSpan">websocket-stream.</span>Server
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Server extends WebSocketServer{
  constructor(opts, cb) {
    super(opts)

    var proxied = false
    this.on('newListener', function(event) {
      if (!proxied &amp;&amp; event === 'stream') {
        proxied = true
        this.on('connection', function(conn) {
          this.emit('stream', stream(conn, opts))
        })
      }
    })

    if (cb) {
      this.on('stream', cb)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.websocket-stream.createServer" id="apidoc.element.websocket-stream.createServer">
        function <span class="apidocSignatureSpan">websocket-stream.</span>createServer
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer = function (opts, cb) {
  return new Server(opts, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### On the server

Using the [`ws`](http://npmjs.org/ws) module you can make a websocket server and use this module to get websocket streams on the
 server:

```javascript
var websocket = require('websocket-stream')
var wss = websocket.<span class="apidocCodeKeywordSpan">createServer</span>({server: someHTTPServer}, handle)

function handle(stream) {
  fs.createReadStream('bigdata.json').pipe(stream)
}
```

We recommend disabling the [per message deflate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.websocket-stream.stream" id="apidoc.element.websocket-stream.stream">
        function <span class="apidocSignatureSpan">websocket-stream.</span>stream
        <span class="apidocSignatureSpan">(target, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketStream(target, protocols, options) {
  var stream, socket

  var isBrowser = process.title === 'browser'
  var isNative = !!global.WebSocket
  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode

  if (protocols &amp;&amp; !Array.isArray(protocols) &amp;&amp; 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols
    protocols = null

    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {
      protocols = options.protocol;
    }
  }

  if (!options) options = {}

  if (options.objectMode === undefined) {
    options.objectMode = !(options.binary === true || options.binary === undefined)
  }

  var proxy = buildProxy(options, socketWrite, socketEnd)

  if (!options.objectMode) {
    proxy._writev = writev
  }

  // browser only: sets the maximum socket buffer size before throttling
  var bufferSize = options.browserBufferSize || 1024 * 512

  // browser only: how long to wait when throttling
  var bufferTimeout = options.browserBufferTimeout || 1000

  // use existing WebSocket object that was passed in
  if (typeof target === 'object') {
    socket = target
  // otherwise make a new one
  } else {
    // special constructor treatment for native websockets in browsers, see
    // https://github.com/maxogden/websocket-stream/issues/82
    if (isNative &amp;&amp; isBrowser) {
      socket = new WS(target, protocols)
    } else {
      socket = new WS(target, protocols, options)
    }

    socket.binaryType = 'arraybuffer'
  }

  // was already open when passed in
  if (socket.readyState === WS.OPEN) {
    stream = proxy
  } else {
    stream = duplexify.obj()
    socket.onopen = onopen
  }

  stream.socket = socket

  socket.onclose = onclose
  socket.onerror = onerror
  socket.onmessage = onmessage

  proxy.on('close', destroy)

  var coerceToBuffer = !options.objectMode

  function socketWriteNode(chunk, enc, next) {
    // avoid errors, this never happens unless
    // destroy() is called
    if (socket.readyState !== WS.OPEN) {
      next()
      return
    }

    if (coerceToBuffer &amp;&amp; typeof chunk === 'string') {
      chunk = new Buffer(chunk, 'utf8')
    }
    socket.send(chunk, next)
  }

  function socketWriteBrowser(chunk, enc, next) {
    if (socket.bufferedAmount &gt; bufferSize) {
      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)
      return
    }

    if (coerceToBuffer &amp;&amp; typeof chunk === 'string') {
      chunk = new Buffer(chunk, 'utf8')
    }

    try {
      socket.send(chunk)
    } catch(err) {
      return next(err)
    }

    next()
  }

  function socketEnd(done) {
    socket.close()
    done()
  }

  function onopen() {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  }

  function onclose() {
    stream.end()
    stream.destroy()
  }

  function onerror(err) {
    stream.destroy(err)
  }

  function onmessage(event) {
    var data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(new Uint8Array(data))
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  }

  function destroy() {
    socket.close()
  }

  // this is to be enabled only if objectMode is false
  function writev (chunks, cb) {
    var buffers = new Array(chunks.length)
    for (var i = 0; i &lt; chunks.length; i++) {
      if (typeof chunks[i].chunk === 'string') {
        buffers[i] = Buffer.from(chunks[i], 'utf8')
      } else {
        buffers[i] = chunks[i].chunk
      }
    }

    this._write(Buffer.concat(buffers), 'binary', cb)
  }

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.websocket-stream.echo_server" id="apidoc.module.websocket-stream.echo_server">module websocket-stream.echo_server</a></h1>


    <h2>
        <a href="#apidoc.element.websocket-stream.echo_server.start" id="apidoc.element.websocket-stream.echo_server.start">
        function <span class="apidocSignatureSpan">websocket-stream.echo_server.</span>start
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (opts, cb) {
  if (server) {
    cb(new Error('already started'));
    return;
  }

  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  server = http.createServer()
  opts.server = server

  websocket.createServer(opts, echo)

  server.listen(port, cb)

  function echo(stream) {
    stream.pipe(stream)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var http = require('http')
var websocket = require('./')
var echo = require('./echo-server.js')
var WebSocketServer = require('ws').Server

echo.<span class="apidocCodeKeywordSpan">start</span>(function(){
console.log('echo server is running')
})

function forBare (opts) {
var server = http.createServer()

websocket.createServer({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.websocket-stream.echo_server.stop" id="apidoc.element.websocket-stream.echo_server.stop">
        function <span class="apidocSignatureSpan">websocket-stream.echo_server.</span>stop
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (cb) {
  if (!server) {
    cb(new Error('not started'))
    return
  }

  server.close(cb)
  server = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  client.on('error', console.error)

  client.on('data', function(data) {
    t.ok(Buffer.isBuffer(data), 'is a buffer')
    t.equal(data.toString(), 'hello world')
    client.end()
    echo.<span class="apidocCodeKeywordSpan">stop</span>(function() {
      t.end()
    })
  })

  client.write('hello world')
})
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.websocket-stream.server" id="apidoc.module.websocket-stream.server">module websocket-stream.server</a></h1>


    <h2>
        <a href="#apidoc.element.websocket-stream.server.Server" id="apidoc.element.websocket-stream.server.Server">
        function <span class="apidocSignatureSpan">websocket-stream.server.</span>Server
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Server extends WebSocketServer{
  constructor(opts, cb) {
    super(opts)

    var proxied = false
    this.on('newListener', function(event) {
      if (!proxied &amp;&amp; event === 'stream') {
        proxied = true
        this.on('connection', function(conn) {
          this.emit('stream', stream(conn, opts))
        })
      }
    })

    if (cb) {
      this.on('stream', cb)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.websocket-stream.server.createServer" id="apidoc.element.websocket-stream.server.createServer">
        function <span class="apidocSignatureSpan">websocket-stream.server.</span>createServer
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer = function (opts, cb) {
  return new Server(opts, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### On the server

Using the [`ws`](http://npmjs.org/ws) module you can make a websocket server and use this module to get websocket streams on the
 server:

```javascript
var websocket = require('websocket-stream')
var wss = websocket.<span class="apidocCodeKeywordSpan">createServer</span>({server: someHTTPServer}, handle)

function handle(stream) {
  fs.createReadStream('bigdata.json').pipe(stream)
}
```

We recommend disabling the [per message deflate
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.websocket-stream.stream" id="apidoc.module.websocket-stream.stream">module websocket-stream.stream</a></h1>


    <h2>
        <a href="#apidoc.element.websocket-stream.stream.stream" id="apidoc.element.websocket-stream.stream.stream">
        function <span class="apidocSignatureSpan">websocket-stream.</span>stream
        <span class="apidocSignatureSpan">(target, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketStream(target, protocols, options) {
  var stream, socket

  var isBrowser = process.title === 'browser'
  var isNative = !!global.WebSocket
  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode

  if (protocols &amp;&amp; !Array.isArray(protocols) &amp;&amp; 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols
    protocols = null

    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {
      protocols = options.protocol;
    }
  }

  if (!options) options = {}

  if (options.objectMode === undefined) {
    options.objectMode = !(options.binary === true || options.binary === undefined)
  }

  var proxy = buildProxy(options, socketWrite, socketEnd)

  if (!options.objectMode) {
    proxy._writev = writev
  }

  // browser only: sets the maximum socket buffer size before throttling
  var bufferSize = options.browserBufferSize || 1024 * 512

  // browser only: how long to wait when throttling
  var bufferTimeout = options.browserBufferTimeout || 1000

  // use existing WebSocket object that was passed in
  if (typeof target === 'object') {
    socket = target
  // otherwise make a new one
  } else {
    // special constructor treatment for native websockets in browsers, see
    // https://github.com/maxogden/websocket-stream/issues/82
    if (isNative &amp;&amp; isBrowser) {
      socket = new WS(target, protocols)
    } else {
      socket = new WS(target, protocols, options)
    }

    socket.binaryType = 'arraybuffer'
  }

  // was already open when passed in
  if (socket.readyState === WS.OPEN) {
    stream = proxy
  } else {
    stream = duplexify.obj()
    socket.onopen = onopen
  }

  stream.socket = socket

  socket.onclose = onclose
  socket.onerror = onerror
  socket.onmessage = onmessage

  proxy.on('close', destroy)

  var coerceToBuffer = !options.objectMode

  function socketWriteNode(chunk, enc, next) {
    // avoid errors, this never happens unless
    // destroy() is called
    if (socket.readyState !== WS.OPEN) {
      next()
      return
    }

    if (coerceToBuffer &amp;&amp; typeof chunk === 'string') {
      chunk = new Buffer(chunk, 'utf8')
    }
    socket.send(chunk, next)
  }

  function socketWriteBrowser(chunk, enc, next) {
    if (socket.bufferedAmount &gt; bufferSize) {
      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)
      return
    }

    if (coerceToBuffer &amp;&amp; typeof chunk === 'string') {
      chunk = new Buffer(chunk, 'utf8')
    }

    try {
      socket.send(chunk)
    } catch(err) {
      return next(err)
    }

    next()
  }

  function socketEnd(done) {
    socket.close()
    done()
  }

  function onopen() {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  }

  function onclose() {
    stream.end()
    stream.destroy()
  }

  function onerror(err) {
    stream.destroy(err)
  }

  function onmessage(event) {
    var data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(new Uint8Array(data))
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  }

  function destroy() {
    socket.close()
  }

  // this is to be enabled only if objectMode is false
  function writev (chunks, cb) {
    var buffers = new Array(chunks.length)
    for (var i = 0; i &lt; chunks.length; i++) {
      if (typeof chunks[i].chunk === 'string') {
        buffers[i] = Buffer.from(chunks[i], 'utf8')
      } else {
        buffers[i] = chunks[i].chunk
      }
    }

    this._write(Buffer.concat(buffers), 'binary', cb)
  }

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.websocket-stream.stream.Server" id="apidoc.element.websocket-stream.stream.Server">
        function <span class="apidocSignatureSpan">websocket-stream.stream.</span>Server
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Server extends WebSocketServer{
  constructor(opts, cb) {
    super(opts)

    var proxied = false
    this.on('newListener', function(event) {
      if (!proxied &amp;&amp; event === 'stream') {
        proxied = true
        this.on('connection', function(conn) {
          this.emit('stream', stream(conn, opts))
        })
      }
    })

    if (cb) {
      this.on('stream', cb)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.websocket-stream.stream.createServer" id="apidoc.element.websocket-stream.stream.createServer">
        function <span class="apidocSignatureSpan">websocket-stream.stream.</span>createServer
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer = function (opts, cb) {
  return new Server(opts, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### On the server

Using the [`ws`](http://npmjs.org/ws) module you can make a websocket server and use this module to get websocket streams on the
 server:

```javascript
var websocket = require('websocket-stream')
var wss = websocket.<span class="apidocCodeKeywordSpan">createServer</span>({server: someHTTPServer}, handle)

function handle(stream) {
  fs.createReadStream('bigdata.json').pipe(stream)
}
```

We recommend disabling the [per message deflate
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>